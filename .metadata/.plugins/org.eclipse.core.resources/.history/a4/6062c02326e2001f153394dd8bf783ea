/*
 * DWT_Delay.h
 *
 *  Created on: Feb 3, 2025
 *      Author: PanTalir
 */

#ifndef SRC_UTIL_DWT_DELAY_H_
#define SRC_UTIL_DWT_DELAY_H_

uint32_t DWT_Delay_Init(void);
__STATIC_INLINE void DWT_Delay_us(volatile uint32_t au32_microseconds);
__STATIC_INLINE void DWT_Delay_ms(volatile uint32_t au32_milliseconds);

/*
uint32_t DWT_Delay_Init(void) {
	//Disable TRC
	CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk; 	//~0x01000000;
	//Enable TRC
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;		// 0x01000000;

	//Disable clock cycle counter
	DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk;				//~0x00000001;
	//Enable clock cycle counter
	DWT->CTRL |= ~DWT_CTRL_CYCCNTENA_Msk;				// 0x00000001;

	//Reset the clock cycle counter
	DWT->CYCCNT = 0;

	// 3 no operation instructions = nop
	__ASM
	volatile ("NOP");
	__ASM
	volatile ("NOP");
	__ASM
	volatile ("NOP");

	//Check if clock cycle counter has started
	if (DWT->CYCCNT) {
		return 0;	//Clock cycle has started
	} else {
		return 1;	//CLock cycle counter not started
	}
}
*/

uint32_t DWT_Delay_Init(void)
{
    /* Disable TRC */
    CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk; // ~0x01000000;
    /* Enable TRC */
    CoreDebug->DEMCR |=  CoreDebug_DEMCR_TRCENA_Msk; // 0x01000000;

    /* Disable clock cycle counter */
    DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; //~0x00000001;
    /* Enable  clock cycle counter */
    DWT->CTRL |=  DWT_CTRL_CYCCNTENA_Msk; //0x00000001;

    /* Reset the clock cycle counter value */
    DWT->CYCCNT = 0;

    /* 3 NO OPERATION instructions */
    __ASM volatile ("NOP");
    __ASM volatile ("NOP");
    __ASM volatile ("NOP");

    /* Check if clock cycle counter has started */
    if(DWT->CYCCNT)
    {
       return 0; /*clock cycle counter started*/
    }
    else
    {
      return 1; /*clock cycle counter not started*/
    }
}























__STATIC_INLINE void DWT_Delay_us(volatile uint32_t au32_microseconds) {
	uint32_t au32_initial_ticks = DWT->CYCCNT;
	uint32_t au32_ticks = (HAL_RCC_GetHCLKFreq() / 1000000);
	au32_microseconds *= au32_ticks;
	while ((DWT->CYCCNT - au32_initial_ticks) < au32_microseconds - au32_ticks) {
	}
}

/*
 __STATIC_INLINE void DWT_Delay_ms(volatile uint32_t au32_miliseconds)
 {
 uint32_t au32_initial_ticks = DWT->CYCCNT;
 uint32_t au32_ticks = ((HAL_RCC_GetHCLKFreq()) / 1000);
 au32_miliseconds *= au32_ticks;
 while((DWT->CYCCNT - au32_initial_ticks) < au32_miliseconds);
 }
 */
// This Function Provides Delay In Milliseconds Using DWT
__STATIC_INLINE void DWT_Delay_ms(volatile uint32_t au32_milliseconds) {
	uint32_t au32_initial_ticks = DWT->CYCCNT;
	uint32_t au32_ticks = (HAL_RCC_GetHCLKFreq() / 1000);
	au32_milliseconds *= au32_ticks;
	while ((DWT->CYCCNT - au32_initial_ticks) < au32_milliseconds)
		;
}

#endif /* SRC_UTIL_DWT_DELAY_H_ */
